// Code generated by xgen. DO NOT EDIT.

use serde::Serialize;
use serde::Deserialize;

use serde_xml_rs::from_reader;

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct DateSimpleType {
	#[serde(rename = "DateSimpleType")]
	pub date_time: u8,
	#[serde(rename = "DateSimpleType")]
	pub date: u8,
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct OccurrenceSimpleType {
	#[serde(rename = "OccurrenceSimpleType")]
	pub choice_enum: ChoiceEnum,
	#[serde(rename = "OccurrenceSimpleType")]
	pub positive_integer: u32,
}


// ShortStringSimpleType is A simple string with not more than 32 characters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ShortStringSimpleType {
	#[serde(rename = "ShortStringSimpleType")]
	pub short_string_simple_type: String,
}


// MediumStringSimpleType is A simple string with not more than 128 characters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct MediumStringSimpleType {
	#[serde(rename = "MediumStringSimpleType")]
	pub medium_string_simple_type: String,
}


// LongStringSimpleType is A simple string with not more than 1024 characters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LongStringSimpleType {
	#[serde(rename = "LongStringSimpleType")]
	pub long_string_simple_type: String,
}


// ChoiceEnum is The choice enumeration is used to enumerate some textual values for
//             use with the occurrence simple type defined above.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ChoiceEnum {
	#[serde(rename = "ChoiceEnum")]
	pub choice_enum: String,
}


// PropertyTypeEnum is The property  type enumeration allows a property to be given a
//             type specification. If the @type attribute is not specified, then
//             the default type is "string".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PropertyTypeEnum {
	#[serde(rename = "PropertyTypeEnum")]
	pub property_type_enum: String,
}


// SetTypeEnum is A "res" is a resource, such as a person, place, or thing and
//                   the properties enclosed within the set describe it.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct SetTypeEnum {
	#[serde(rename = "SetTypeEnum")]
	pub set_type_enum: String,
}


// StatusEnum is A "unknown" status indicates that the status is not known.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct StatusEnum {
	#[serde(rename = "StatusEnum")]
	pub status_enum: String,
}


// ActionTypeEnum is The "delete" action removes text from a proposed provision to
//                   the law.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ActionTypeEnum {
	#[serde(rename = "ActionTypeEnum")]
	pub action_type_enum: String,
}


// PositionEnum is The position enumeration is used with references found within
//             amendments when it is necessary to specify a position relative to an
//             item rather than when referencing the item itself.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PositionEnum {
	#[serde(rename = "PositionEnum")]
	pub position_enum: String,
}


// OrientationEnum is The orientation enumeration is used specify how an item should be
//             oriented in the printed form. The orientation can be specified
//             for any content item or for any appendix item, including a
//             schedule.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct OrientationEnum {
	#[serde(rename = "OrientationEnum")]
	pub orientation_enum: String,
}


// NoteTypeEnum is Notes can be placed inline, as footnotes at the end of the page,
//             as end notes as the end of document, or U.S. Code notes. By default,
//             notes are inline
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NoteTypeEnum {
	#[serde(rename = "NoteTypeEnum")]
	pub note_type_enum: String,
}


// IdentificationGroup is Use the @identifier attribute to specify the URL context of the
//                element. Typically, the @identifier will be established on the
//                root element or on any element, such as a <quotedStructure> or
//                <quotedText> element, that changes the context.
// 
//                The @identifier attribute is optional.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct IdentificationGroup {
	#[serde(rename = "id")]
	pub id: Option<String>,
	#[serde(rename = "name")]
	pub name: Option<String>,
	#[serde(rename = "temporalId")]
	pub temporal_id: Option<String>,
	#[serde(rename = "identifier")]
	pub identifier: Option<String>,
}


// ClassificationGroup is The @style attribute is used to specify CSS attributes that
//                override the default styles defined for an element or an element
//                class. The current loose-leaf publication standards should be
//                specified using an external style sheet and the use of the @style
//                attribute should be reserved for exception cases where the
//                default presentation must be overridden.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ClassificationGroup {
	#[serde(rename = "role")]
	pub role: Option<String>,
	#[serde(rename = "class")]
	pub class: Option<String>,
	#[serde(rename = "style")]
	pub style: Option<String>,
}


// AnnotationGroup is The @codificationTip is for internal use by the OLRC.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct AnnotationGroup {
	#[serde(rename = "note")]
	pub note: Option<String>,
	#[serde(rename = "alt")]
	pub alt: Option<String>,
	#[serde(rename = "meta")]
	pub meta: Option<String>,
	#[serde(rename = "misc")]
	pub misc: Option<String>,
	#[serde(rename = "draftingTip")]
	pub drafting_tip: Option<String>,
	#[serde(rename = "codificationTip")]
	pub codification_tip: Option<String>,
}


// DescriptionGroup is The @sortOrder attribute is used to specify a sorting order for
//                a list of items, when that sort order is not the document
//                sequence. The @sortOrder value must be specified as a positive
//                integer. This attribute should rarely be used.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct DescriptionGroup {
	#[serde(rename = "title")]
	pub title: Option<String>,
	#[serde(rename = "brief")]
	pub brief: Option<String>,
	#[serde(rename = "sortOrder")]
	pub sort_order: Option<i32>,
}


// ReferenceGroup is The @portion attribute is used, in conjunction with the @idref
//                attribute, when only a portion of the referenced item is being
//                affected. The value of @portion is an additional part to append
//                to the URL, with a "/" separator to identify the item affected.
//                Do not include a leading "/" in the @portion value.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ReferenceGroup {
	#[serde(rename = "href")]
	pub href: Option<String>,
	#[serde(rename = "idref")]
	pub idref: Option<String>,
	#[serde(rename = "portion")]
	pub portion: Option<String>,
}


// AmendingGroup is The @posCount attribute is used to specify the number of
//                occurrences of the @posText to seek out when establishing the
//                context.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct AmendingGroup {
	#[serde(rename = "pos")]
	pub pos: Option<String>,
	#[serde(rename = "posText")]
	pub pos_text: Option<String>,
	#[serde(rename = "posCount")]
	pub pos_count: Option<u32>,
}


// LinkGroup is The @src attribute is a URL that points to an item to be included
//                in the published document. Unlike an @href attribute, a @src
//                attribute can be any normal URL and can be relative or absolute.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LinkGroup {
	#[serde(rename = "src")]
	pub src: Option<String>,
}


// ValueGroup is The @endValue attribute is used for the upper end of a value
//             range.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ValueGroup {
	#[serde(rename = "value")]
	pub value: Option<String>,
	#[serde(rename = "startValue")]
	pub start_value: Option<String>,
	#[serde(rename = "endValue")]
	pub end_value: Option<String>,
}


// NoteGroup is Set the @topic attribute to a string value in order
//                      to categorize the note or group of notes. An open,
//                      but enumerated, list of string values should be used.
//                      Using a fixed list of values will better aid in
//                      categorization of notes later.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NoteGroup {
	#[serde(rename = "type")]
	pub type_attr: Option<String>,
	#[serde(rename = "topic")]
	pub topic: Option<String>,
}


// DateGroup is The @endDate attribute is used for the ending date of a date
//                range.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct DateGroup {
	#[serde(rename = "date")]
	pub date: Option<DateSimpleType>,
	#[serde(rename = "startDate")]
	pub start_date: Option<DateSimpleType>,
	#[serde(rename = "endDate")]
	pub end_date: Option<DateSimpleType>,
}


// VersioningGroup is The @partial attribute is used, in conjunction with the
//                @status attribute to indicate that the status is not fully
//                applied.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct VersioningGroup {
	#[serde(rename = "startPeriod")]
	pub start_period: Option<DateSimpleType>,
	#[serde(rename = "endPeriod")]
	pub end_period: Option<DateSimpleType>,
	#[serde(rename = "status")]
	pub status: Option<String>,
	#[serde(rename = "partial")]
	pub partial: Option<bool>,
}


// ActionGroup is The @commencementDate attribute specifies the date upon which the
//                action is to be applied.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ActionGroup {
	#[serde(rename = "type")]
	pub type_attr: Option<String>,
	#[serde(rename = "occurrence")]
	pub occurrence: Option<OccurrenceSimpleType>,
	#[serde(rename = "commencementDate")]
	pub commencement_date: Option<DateSimpleType>,
}


// CellGroup is The @leaders attribute specifies whether leaders should be
//             shown either trailing or following the text content. The character
//             included as the value is the character used to render the leaders.
// 
//             Use the CSS text-align character to position the text. If you
//             align the text to the left, then the leaders will show to the
//             right and if you align the text to the right, then the leaders
//             will show to the left.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct CellGroup {
	#[serde(rename = "colspan")]
	pub colspan: Option<i32>,
	#[serde(rename = "rowspan")]
	pub rowspan: Option<i32>,
	#[serde(rename = "leaders")]
	pub leaders: Option<String>,
}


// BaseType is The base type defines the most general element, specifying the
//             attributes which can be found on all elements - specifically
//             attributes belonging to the identification, classification, and
//             annotation groups.
// 
//             The base type is defined as an abstract type and elements cannot
//             be declared based on it.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct BaseType {
	#[serde(rename = "IdentificationGroup")]
	pub identification_group: Vec<IdentificationGroup>,
	#[serde(rename = "ClassificationGroup")]
	pub classification_group: Vec<ClassificationGroup>,
	#[serde(rename = "AnnotationGroup")]
	pub annotation_group: Vec<AnnotationGroup>,
	#[serde(rename = "VersioningGroup")]
	pub versioning_group: Vec<VersioningGroup>,
	#[serde(rename = "$value")]
	pub value: String,
}


// BaseBlockType is The base block type is a variant of the base type, but having a
//             content structure to support block level children - elements
//             but no text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct BaseBlockType {
	#[serde(rename = "IdentificationGroup")]
	pub identification_group: Vec<IdentificationGroup>,
	#[serde(rename = "ClassificationGroup")]
	pub classification_group: Vec<ClassificationGroup>,
	#[serde(rename = "AnnotationGroup")]
	pub annotation_group: Vec<AnnotationGroup>,
	#[serde(rename = "VersioningGroup")]
	pub versioning_group: Vec<VersioningGroup>,
}


// BaseContentType is The base content type is a variant of the base type, but having
//             a very open content model including text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct BaseContentType {
	#[serde(rename = "IdentificationGroup")]
	pub identification_group: Vec<IdentificationGroup>,
	#[serde(rename = "ClassificationGroup")]
	pub classification_group: Vec<ClassificationGroup>,
	#[serde(rename = "AnnotationGroup")]
	pub annotation_group: Vec<AnnotationGroup>,
	#[serde(rename = "VersioningGroup")]
	pub versioning_group: Vec<VersioningGroup>,
}


// MarkerType is The marker type is a restriction of the base type to an element
//             without content.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct MarkerType {
}


// InlineType is The inline type is a extension of the base type to text content or
//             other inline elements.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct InlineType {
	#[serde(rename = "marker")]
	pub marker: Vec<MarkerType>,
	#[serde(rename = "inline")]
	pub inline: Vec<InlineType>,
	#[serde(flatten)]
	pub base_content_type: BaseContentType,
}


// BlockType is The block type is a extension of the base type to content
//             consisting of only elements.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct BlockType {
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// TextType is The text type is a broad base type allowing any content.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct TextType {
	#[serde(flatten)]
	pub base_content_type: BaseContentType,
}


// ContentType is The content type is a broad base type allowing any content.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ContentType {
	#[serde(rename = "orientation")]
	pub orientation: Option<String>,
	#[serde(flatten)]
	pub base_content_type: BaseContentType,
}


// marker is The <marker> element is a primitive element to be used to mark or
//             denote a spot in the text. I can be used in the <content> areas or
//             anywhere else where an <inline> element is expected. The <marker>
//             element contains no text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct marker {
	#[serde(rename = "marker")]
	pub marker: MarkerType,
}


// inline is The <inline> element is a primitive element to be used within
//             <content> areas or within any other areas which can accept
//             inline content.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct inline {
	#[serde(rename = "inline")]
	pub inline: InlineType,
}


// block is The <block> element is a primitive element to be used anywhere
//             where <block> elements are permitted including within <content>
//             elements or anywhere where <block> elements have been explicitly
//             permitted.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct block {
	#[serde(rename = "block")]
	pub block: BlockType,
}


// content is The <content> element is a primitive element to be used anywhere
//             where a very general content model is desired, including within
//             other <content> elements.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct content {
	#[serde(rename = "content")]
	pub content: ContentType,
}


// LawDocType is In addition to the main part of the document, a document
//                         may have one or more appendices such as schedules or
//                         explanatory memorandums/notes. These appendices can
//                         either be inline documents or the can be external
//                         referenced documents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LawDocType {
	#[serde(rename = "meta")]
	pub meta: MetaType,
	#[serde(rename = "main")]
	pub main: MainType,
	#[serde(rename = "block")]
	pub block: Vec<BlockType>,
	#[serde(rename = "appendix")]
	pub appendix: Vec<AppendixType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// GenericDocType is In addition to the content part of the document, a document
//                         may have one or more appendices.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct GenericDocType {
	#[serde(rename = "meta")]
	pub meta: MetaType,
	#[serde(rename = "content")]
	pub content: ContentType,
	#[serde(rename = "appendix")]
	pub appendix: Vec<AppendixType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// MetaType is Properties can be grouped into sets. These set can
//                         be used to represent something like a series of events,
//                         a person, or another other object related to the
//                         document.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct MetaType {
	#[serde(rename = "property")]
	pub property: Vec<PropertyType>,
	#[serde(rename = "set")]
	pub set: Vec<SetType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// PropertyType is A property can represent a pointer to either an external
//                   document or an element within the document.
// 
//                   You can use a ref to create a pointer to an endnote or a
//                   footnote. In that case, the ref text will be the endnote or
//                   footnote indicator as seen in "<ref idref="fn000001">†</ref>"
//                   where the dagger is the indicator. An endnote or footnote
//                   reference should always use the @idref attribute to point to
//                   an endnote or a footnote within the document.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PropertyType {
	#[serde(rename = "DateGroup")]
	pub date_group: Vec<DateGroup>,
	#[serde(rename = "ValueGroup")]
	pub value_group: Vec<ValueGroup>,
	#[serde(rename = "ReferenceGroup")]
	pub reference_group: Vec<ReferenceGroup>,
	#[serde(rename = "type")]
	pub type_attr: Option<String>,
	#[serde(flatten)]
	pub inline_type: InlineType,
}


// SetType is A set can contain 0 or more sets.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct SetType {
	#[serde(rename = "type")]
	pub type_attr: Option<String>,
	#[serde(rename = "property")]
	pub property: Vec<PropertyType>,
	#[serde(rename = "set")]
	pub set: Vec<SetType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// TocType is The items in a table of contents can be arranged in
//                         a tabular fashion by surrounding the items in a layout.
//                         When a layout is specified, use <column> elements
//                         within each <tocItem> to indicate specific columns.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct TocType {
	#[serde(rename = "generate")]
	pub generate: Option<bool>,
	#[serde(rename = "HeadingStructure")]
	pub heading_structure: HeadingStructure,
	#[serde(rename = "tocItem")]
	pub toc_item: Vec<TocItemType>,
	#[serde(rename = "layout")]
	pub layout: Vec<LayoutType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// TocItemType is Use the description group to record the number and title in the
//                   table of contents as metadata.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct TocItemType {
	#[serde(rename = "DescriptionGroup")]
	pub description_group: Vec<DescriptionGroup>,
	#[serde(rename = "HeadingStructure")]
	pub heading_structure: HeadingStructure,
	#[serde(rename = "tocItem")]
	pub toc_item: Vec<TocItemType>,
	#[serde(rename = "content")]
	pub content: Vec<ContentType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// MainType is The document is permitted to be empty to allow for the
//                         case when the document is newly created and still in a
//                         drafting state.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct MainType {
	#[serde(rename = "NoteStructure")]
	pub note_structure: Vec<NoteStructure>,
	#[serde(rename = "PreambleStructure")]
	pub preamble_structure: PreambleStructure,
	#[serde(rename = "LevelStructure")]
	pub level_structure: LevelStructure,
	#[serde(rename = "property")]
	pub property: Vec<PropertyType>,
	#[serde(rename = "block")]
	pub block: Vec<BlockType>,
	#[serde(rename = "statement")]
	pub statement: Vec<StatementType>,
	#[serde(rename = "toc")]
	pub toc: Vec<TocType>,
}


// StatementType is The attributes of the description group can be used to
//                   record a number and title for a statement for use when
//                   generating a table of contents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct StatementType {
	#[serde(rename = "DescriptionGroup")]
	pub description_group: Vec<DescriptionGroup>,
	#[serde(rename = "marker")]
	pub marker: Vec<MarkerType>,
	#[serde(rename = "inline")]
	pub inline: Vec<InlineType>,
	#[serde(rename = "block")]
	pub block: Vec<BlockType>,
	#[serde(rename = "text")]
	pub text: Vec<TextType>,
	#[serde(rename = "content")]
	pub content: Vec<ContentType>,
	#[serde(rename = "level")]
	pub level: Vec<LevelType>,
	#[serde(flatten)]
	pub base_content_type: BaseContentType,
}


// PreambleType is Attributes from the description group may be used to
//                      attach information to the preamble for use in generating
//                      a table of contents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PreambleType {
	#[serde(rename = "DescriptionGroup")]
	pub description_group: Vec<DescriptionGroup>,
	#[serde(rename = "HeadingStructure")]
	pub heading_structure: HeadingStructure,
	#[serde(rename = "RecitalStructure")]
	pub recital_structure: Vec<RecitalStructure>,
	#[serde(rename = "enactingFormula")]
	pub enacting_formula: StatementType,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// LevelType is Use the description group to record information in the
//                      attributes to be used when generating the table of contents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LevelType {
	#[serde(rename = "DescriptionGroup")]
	pub description_group: Vec<DescriptionGroup>,
	#[serde(rename = "NumStructure")]
	pub num_structure: NumStructure,
	#[serde(rename = "HeadingStructure")]
	pub heading_structure: HeadingStructure,
	#[serde(rename = "TocStructure")]
	pub toc_structure: Vec<TocStructure>,
	#[serde(rename = "LevelStructure")]
	pub level_structure: LevelStructure,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// NumType is Use the @value attribute to record a normalized value of
//                      the <num> content. When the text content represents a
//                      range of values, use the @beginValue and @endValue
//                      attributes to record the range.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NumType {
	#[serde(rename = "ValueGroup")]
	pub value_group: Vec<ValueGroup>,
	#[serde(flatten)]
	pub inline_type: InlineType,
}


// HeadingType is The heading type is used to define heading and subheadings for
//             levels and other structured items. Often a heading will follow
//             a number.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct HeadingType {
	#[serde(flatten)]
	pub content_type: ContentType,
}


// InstructionType is A quoted structure may be associated with an
//                            action (by position) as part of the processing
//                            action.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct InstructionType {
	#[serde(rename = "ref")]
	pub ref_attr: RefType,
	#[serde(rename = "inline")]
	pub inline: Vec<InlineType>,
	#[serde(rename = "marker")]
	pub marker: Vec<MarkerType>,
	#[serde(rename = "action")]
	pub action: Vec<ActionType>,
	#[serde(rename = "level")]
	pub level: Vec<LevelType>,
	#[serde(rename = "quotedText")]
	pub quoted_text: QuotedTextType,
	#[serde(rename = "quotedContent")]
	pub quoted_content: QuotedContentType,
	#[serde(flatten)]
	pub base_content_type: BaseContentType,
}


// ActionType is Use the @action attribute to describe the action being taken.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ActionType {
	#[serde(rename = "ReferenceGroup")]
	pub reference_group: Vec<ReferenceGroup>,
	#[serde(rename = "AmendingGroup")]
	pub amending_group: Vec<AmendingGroup>,
	#[serde(rename = "ActionGroup")]
	pub action_group: Vec<ActionGroup>,
	#[serde(flatten)]
	pub inline_type: InlineType,
}


// NotesType is You can use the @type attribute to position the notes
//                      and the @topic attribute to categorize the notes.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NotesType {
	#[serde(rename = "NoteGroup")]
	pub note_group: Vec<NoteGroup>,
	#[serde(rename = "heading")]
	pub heading: HeadingType,
	#[serde(rename = "subheading")]
	pub subheading: Vec<HeadingType>,
	#[serde(rename = "note")]
	pub note: Vec<NoteType>,
	#[serde(rename = "layout")]
	pub layout: LayoutType,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// NoteType is You can use the @date to associate dates to your notes.
//                      This can be used to generate alerts.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NoteType {
	#[serde(rename = "NoteGroup")]
	pub note_group: Vec<NoteGroup>,
	#[serde(rename = "DateGroup")]
	pub date_group: Vec<DateGroup>,
	#[serde(flatten)]
	pub content_type: ContentType,
}


// AppendixType is If an <appendix> is to be included by reference, use the
//                      @src attribute with a normal URL to point to the document
//                      to be included.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct AppendixType {
	#[serde(rename = "DescriptionGroup")]
	pub description_group: Vec<DescriptionGroup>,
	#[serde(rename = "LinkGroup")]
	pub link_group: Vec<LinkGroup>,
	#[serde(rename = "orientation")]
	pub orientation: Option<String>,
	#[serde(rename = "NumStructure")]
	pub num_structure: NumStructure,
	#[serde(rename = "HeadingStructure")]
	pub heading_structure: HeadingStructure,
	#[serde(rename = "TocStructure")]
	pub toc_structure: TocStructure,
	#[serde(rename = "LevelStructure")]
	pub level_structure: LevelStructure,
	#[serde(rename = "block")]
	pub block: BlockType,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// SignaturesType is Defines a block for a collection of signatures. An opening paragraph
//             is permitted as well as an ending date. In some cases, the date may
//             appear within the opening paragraph.
// 
//             The signatures may either be specified serially in a grid-like
//             layout.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct SignaturesType {
	#[serde(rename = "p")]
	pub p: PType,
	#[serde(rename = "signature")]
	pub signature: Vec<SignatureType>,
	#[serde(rename = "layout")]
	pub layout: LayoutType,
	#[serde(rename = "date")]
	pub date: u8,
}


// Name ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct Name {
}


// Role ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct Role {
}


// Affiliation ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct Affiliation {
}


// SignatureType is Defines a basic signature element comprising a name and optionally
//             the person's role, their affiliation, and a date. All fields can be
//             defined to include either an @href or an @idref to point to an
//             identifying resource that describes the person, their role, and
//             their affiliation.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct SignatureType {
	#[serde(rename = "name")]
	pub name: Name,
	#[serde(rename = "role")]
	pub role: Role,
	#[serde(rename = "affiliation")]
	pub affiliation: Affiliation,
	#[serde(rename = "date")]
	pub date: u8,
}


// RefType is Use the @pos and other attributes to describe
//                      what or where is being affected.
// 
//                      The attributes in the amending group should only be used
//                      for references or actions within an amending instruction.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct RefType {
	#[serde(rename = "AmendingGroup")]
	pub amending_group: Vec<AmendingGroup>,
	#[serde(flatten)]
	pub property_type: PropertyType,
}


// DateType is Use the @date attribute to record a normalized value of the
//                      date according to ISO 8601.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct DateType {
	#[serde(rename = "DateGroup")]
	pub date_group: Vec<DateGroup>,
}


// QuotedTextType is A quoted text type is an extraction of simple text from another
//             source or origin. If the quoted text is to have literal quotes
//             surrounding it, then those characters must be included in the text
//             surrounding the quoted text and not within it.
// 
//             Quoted text is seen in amendments or modifications.
// 
//             Use the @identifier attribute to establish the referencing context
//             of the quoted text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct QuotedTextType {
	#[serde(rename = "origin")]
	pub origin: Option<String>,
	#[serde(flatten)]
	pub inline_type: InlineType,
}


// QuotedContentType is A quotedContentType is used for an extraction of potentially structured
//             text (text with XML elements) from another source or origin.
// 
//             Quoted content is seen in USC Notes, amendments, and modifications.
// 
//             Use the @identifier attribute to establish the referencing context
//             of the quoted structure
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct QuotedContentType {
	#[serde(rename = "origin")]
	pub origin: Option<String>,
	#[serde(flatten)]
	pub content_type: ContentType,
}


// NoteStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NoteStructure {
	#[serde(rename = "note")]
	pub note: NoteType,
	#[serde(rename = "notes")]
	pub notes: NotesType,
}


// NumStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct NumStructure {
	#[serde(rename = "num")]
	pub num: NumType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// HeadingStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct HeadingStructure {
	#[serde(rename = "heading")]
	pub heading: HeadingType,
	#[serde(rename = "subheading")]
	pub subheading: HeadingType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// TocStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct TocStructure {
	#[serde(rename = "toc")]
	pub toc: TocType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// StatementStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct StatementStructure {
	#[serde(rename = "statement")]
	pub statement: StatementType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// RecitalStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct RecitalStructure {
	#[serde(rename = "recital")]
	pub recital: StatementType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// PreambleStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PreambleStructure {
	#[serde(rename = "preamble")]
	pub preamble: PreambleType,
	#[serde(rename = "enactingFormula")]
	pub enacting_formula: StatementType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// LevelStructure ...
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LevelStructure {
	#[serde(rename = "instruction")]
	pub instruction: InstructionType,
	#[serde(rename = "content")]
	pub content: ContentType,
	#[serde(rename = "text")]
	pub text: TextType,
	#[serde(rename = "level")]
	pub level: LevelType,
	#[serde(rename = "crossHeading")]
	pub cross_heading: HeadingType,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
	#[serde(rename = "NoteStructure")]
	pub note_structure: NoteStructure,
}


// law_doc is A <lawDoc> is a base level element representing all types of
//             legislative documents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct law_doc {
	#[serde(rename = "lawDoc")]
	pub law_doc: LawDocType,
}


// document is A <document> is a base level element for loosely structured
//             documents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct document {
	#[serde(rename = "document")]
	pub document: GenericDocType,
}


// meta is A <meta> block contains properties and sets of properties recording
//             metadata about the document. The information contained within the
//             meta block is not part of the official law and should not be printed
//             as such. Ordinarily, all text content in a document is intended for
//             publication in textual representations of the document. However,
//             this is not the case for textual content in the <meta> block. If,
//             for instance, a property in the meta block has text content, it
//             does not automatically become text to be included in a published
//             form. However, in some case this may be desirable and can be done.
//             However, the meaning is not implicit.
// 
//             The <meta> block may contain elements from the Dublin Core.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct meta {
	#[serde(rename = "meta")]
	pub meta: MetaType,
}


// property is A <property> is simple value recorded with the document. Typically
//             properties are stored in the <meta> block of the document. However,
//             this is not necessarily the case. It is possible to also define
//             properties within any content area in the document. A case where
//             this occurs is the definition of the short title. The short title
//             is treated as a property (the <docTitle> element is a derivation
//             from the <property> element).
// 
//             If a property in the <meta> block has textual content, then this
//             text is not implicitly intended for publication. However, if a
//             property outside the <meta> block has textual content, then this
//             text is implicitly intended for publication.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct property {
	#[serde(rename = "property")]
	pub property: PropertyType,
}


// set is A <set> is a grouping of properties in the <meta> block. Sets
//             themselves can contain other sets. Sets can be typed using the
//             @type attribute with the SetTypeEnum enumeration. By default, sets
//             are simply unordered bags of properties.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct set {
	#[serde(rename = "set")]
	pub set: SetType,
}


// toc is A <toc> is a table of contents. A table of contents can appear in a
//             number of locations in document. A table of contents can appear in
//             three different locations:
// 
//             - It can appear anywhere within the top of the <main> element,
//               before the levels.
//             - It can appear in any level following the <heading>, <subheading>,
//               and any notes.
//             - It can appear in an <appendix>.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct toc {
	#[serde(rename = "toc")]
	pub toc: TocType,
}


// toc_item is A <tocItem> is an entry in a table of contents. In addition to being
//             found within a <toc> element, a <tocItem> can contain other <tocItem>
//             elements in a hierarchy.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct toc_item {
	#[serde(rename = "tocItem")]
	pub toc_item: TocItemType,
}


// main is A <main> is the primary container for the body of a legislative
//             document.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct main {
	#[serde(rename = "main")]
	pub main: MainType,
}


// statement is A <statement> is the general container for the provisions at the
//             beginning of legislation.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct statement {
	#[serde(rename = "statement")]
	pub statement: StatementType,
}


// preamble is The <preamble> is a container for the "Whereas" clauses and the
//             enacting formula. Modern practice is to not use the preamble,
//             but to use a standalone enacting formula. However, for the rare
//             cases where a preamble is desired, the tags are made available.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct preamble {
	#[serde(rename = "preamble")]
	pub preamble: PreambleType,
}


// recital is A <recital> is a preliminary statement in a bill stating the reasons
//             for the Bill. Modern legislation seldom uses a recital although it
//             can still occur.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct recital {
	#[serde(rename = "recital")]
	pub recital: StatementType,
}


// enacting_formula is The <enactingFormula> is specified just before the main provisions of
//             a bill. The <enactingFormula> can appear as either the last statement
//             in a preamble or, when a preamble is not present, standalone within
//             the main element just prior to the main provisions.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct enacting_formula {
	#[serde(rename = "enactingFormula")]
	pub enacting_formula: StatementType,
}


// level is A <level> is the general container for the main provisions of
//             legislation, often organized as a hierarchy.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct level {
	#[serde(rename = "level")]
	pub level: LevelType,
}


// num is The <num> surrounds the numeric designation assigned to a level
//             in legislation. Numbering is not always present. The number should
//             always include the surrounding decoration including descriptive
//             text and parenthesis and grammar. This number should never be
//             auto-generated. A normalized value based on the text content of the
//             <num> element should be stored in the @value attribute.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct num {
	#[serde(rename = "num")]
	pub num: NumType,
}


// text is The <text> element is a base class for <chapeau>, <continuation>,
//             <proviso>, <def> and any other type of text that can be interspersed
//             in the hierarchy of a document. It is similar to the <content> tag,
//             but has more limited applicability. In general, use the <content>
//             tag when a hierarchical level is made up largely of general content
//             and use the one of its derivatives of the text tag when limited text
//             is found interstitially between levels or other tags.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct text {
	#[serde(rename = "text")]
	pub text: TextType,
}


// heading is The <heading> is an optional part of a level element and various other
//             elements. The heading is based on the content primitive and can contain
//             various elements including definitions.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct heading {
	#[serde(rename = "heading")]
	pub heading: HeadingType,
}


// subheading is The <subheading> is an optional part of a level element and various
//             other elements. Like the heading, the subheading is based on the
//             content primitive and can contain various elements including
//             definitions. A subheading should only be created if a heading
//             already exists.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subheading {
	#[serde(rename = "subheading")]
	pub subheading: HeadingType,
}


// cross_heading is A <crossHeading> is a non-hierarchical heading construct which can
//             be placed within and amongst heading levels. A <crossHeading> acts
//             as a divider, separating items within a level.
// 
//             Cross headings are typically shown as center-aligned headings
//             without any level identification or level numbering.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct cross_heading {
	#[serde(rename = "crossHeading")]
	pub cross_heading: HeadingType,
}


// instruction is An <instruction> is a container having formalized text describing an
//             amendment or a modification. An <instruction> contains the <action>s
//             and <quotedText>/<quotedContent> necessary to describe an
//             amendment.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct instruction {
	#[serde(rename = "instruction")]
	pub instruction: InstructionType,
}


// action is An <action> is an atomic-level change defined within an amending
//             formula. The action contains the text related to that action and,
//             through attributes, identifies the item affected and the type of
//             action to be performed.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct action {
	#[serde(rename = "action")]
	pub action: ActionType,
}


// notes is The <notes> is a container for collections of individual notes.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct notes {
	#[serde(rename = "notes")]
	pub notes: NotesType,
}


// note is A <note> is a generic element for notes associated with items in the
//             document. Typically, a derived note type should be used to
//             differentiate between official statutory notes and unofficial
//             editorial notes.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct note {
	#[serde(rename = "note")]
	pub note: NoteType,
}


// appendix is An <appendix> is a generic element appended to the main part of a
//             document. Appendices can either be inline or included via a @src
//             reference. Typically the appendix tag is not used. Rather, the
//             derived tags such as <schedule> and <explanation> are used instead.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct appendix {
	#[serde(rename = "appendix")]
	pub appendix: AppendixType,
}


// signatures is Some documents, may conclude with one or
//             more signatures indicating sponsorship or approval. These
//             signatures are placed within this container.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct signatures {
	#[serde(rename = "signatures")]
	pub signatures: SignaturesType,
}


// signature is A <signature> consists of a name and, optionally, role, affiliation,
//             and/or date. Both the name and the role may be hyperlinked to something
//             which identifies the person or role.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct signature {
	#[serde(rename = "signature")]
	pub signature: SignatureType,
}


// ref_attr is A <ref> element is a reference or link to another document, a
//             location within another document, or a location with the same
//             document.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ref_attr {
	#[serde(rename = "ref")]
	pub ref_attr: RefType,
}


// date is A <date> element is a wrapper around dates. A normalized value
//             of the date text can be stored in the @date attribute or in the
//             @startDate and @endDate attributes in the case of a date range.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct date {
	#[serde(rename = "date")]
	pub date: DateType,
}


// quoted_text is A <quotedText> element is used for an extraction of simple text from
//             another source or origin. If the quoted text is to have literal
//             quotes surrounding it, then those characters must be included in the
//             text surrounding the quoted text and not within it.
// 
//             Quoted text is seen in amendments or modifications.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct quoted_text {
	#[serde(rename = "quotedText")]
	pub quoted_text: QuotedTextType,
}


// quoted_content is A <quotedContent> element is used for an extraction of potentially structured
//             text (text with XML elements) from another source or origin.
// 
//             Quoted content is used in USC Notes, amendments, and modifications.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct quoted_content {
	#[serde(rename = "quotedContent")]
	pub quoted_content: QuotedContentType,
}


// LayoutType is A <layout> type can contain various types of elements
//                      as rows including headers, rows, TOC items, blocks,
//                      and contents. All elements, aside from <column> elements,
//                      are treated as rows when found directly within a layout
//                      structure.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct LayoutType {
	#[serde(rename = "orientation")]
	pub orientation: Option<String>,
	#[serde(rename = "NoteStructure")]
	pub note_structure: Vec<NoteStructure>,
	#[serde(rename = "header")]
	pub header: Vec<RowType>,
	#[serde(rename = "row")]
	pub row: Vec<RowType>,
	#[serde(rename = "tocItem")]
	pub toc_item: Vec<TocItemType>,
	#[serde(rename = "block")]
	pub block: Vec<BlockType>,
	#[serde(rename = "content")]
	pub content: Vec<ContentType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// RowType is A row contains one or more column cells.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct RowType {
	#[serde(rename = "column")]
	pub column: Vec<ColumnType>,
	#[serde(flatten)]
	pub base_block_type: BaseBlockType,
}


// ColumnType is Use the elements of the cell group to specify
//                      the row and column spans.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ColumnType {
	#[serde(rename = "CellGroup")]
	pub cell_group: Vec<CellGroup>,
	#[serde(flatten)]
	pub content_type: ContentType,
}


// PType is A "P" type is a simple unnumbered paragraph. As a <content>
//             element, it can contain a wide range of text and elements.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct PType {
	#[serde(flatten)]
	pub content_type: ContentType,
}


// BrType is A break type is simple marker element denoting a line break.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct BrType {
	#[serde(flatten)]
	pub marker_type: MarkerType,
}


// ImgType is An image type is a simple marker element denoting where a graphic
//             image is to be inserted.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ImgType {
	#[serde(rename = "LinkGroup")]
	pub link_group: Vec<LinkGroup>,
	#[serde(rename = "orientation")]
	pub orientation: Option<String>,
	#[serde(flatten)]
	pub marker_type: MarkerType,
}


// layout is A <layout> element is used to denote an area of text intended to
//             be displayed in a columns-oriented format similar to table. Use
//             the <header>, <row>, and <column> elements to denote the rows and
//             columns of the structure.
// 
//             Use <layout> when describing legislative structure in a column-
//             oriented fashion. For regular tables as shown for forms, use HTML
//             tables.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct layout {
	#[serde(rename = "layout")]
	pub layout: LayoutType,
}


// header is A <header> denotes a header row within a column-based structure.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct header {
	#[serde(rename = "header")]
	pub header: RowType,
}


// row is A <row> denotes a row entry within a column-based structure.
//             In addition to the formal <row> element, any child element
//             in a <layout> element, aside from a <column> element, is regarded as
//             a row. There should always be a <layout> element as an
//             ancestor of a <row>. Both column and row spans may be defined for
//             <row> entries.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct row {
	#[serde(rename = "row")]
	pub row: RowType,
}


// column is A <column> denotes a column when specified directly under a <layout>
//             or a cell when specified within a <row> (or equivalent) in a
//             <layout> structure. There should always be a <layout> element as an
//             ancestor of a <column>. Both column and row spans may be defined for
//             <column> entries.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct column {
	#[serde(rename = "column")]
	pub column: ColumnType,
}


// p is A <p> is a simple paragraph. This is different from the
//             more complex numbered <paragraph> element used for
//             the formal paragraph level of legislative documents.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct p {
	#[serde(rename = "p")]
	pub p: PType,
}


// br is A <br> is simple marker element denoting a line break.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct br {
	#[serde(rename = "br")]
	pub br: BrType,
}


// img is An <img> is a simple marker element denoting where a graphic
//             image is to be inserted. Use the @src attribute to point to the
//             image with a normal URL.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct img {
	#[serde(rename = "img")]
	pub img: ImgType,
}


// center is A <center> is content text to be centered on the page.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct center {
	#[serde(rename = "center")]
	pub center: ContentType,
}


// fill_in is A <fillIn> is an inline spacer which denotes an area to be filled
//             in a printed form. Usually, a <fillIn> is rendered as dotted lines
//             with the text content within the <fillIn> tags shown just below. If
//             parenthesis are to surround the text shown below the line, then
//             those parenthesis should be included in the text content.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct fill_in {
	#[serde(rename = "fillIn")]
	pub fill_in: ContentType,
}


// check_box is A <checkBox> is an inline tick box which denotes a box to be filled
//             in on an form.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct check_box {
	#[serde(rename = "checkBox")]
	pub check_box: ContentType,
}


// b is A <b> is a simple inline text to be shown in bold text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct b {
	#[serde(rename = "b")]
	pub b: InlineType,
}


// i is An <i> is a simple inline text to be shown in italic text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct i {
	#[serde(rename = "i")]
	pub i: InlineType,
}


// sub is A <sub> is a simple inline text to be shown in subscript text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct sub {
	#[serde(rename = "sub")]
	pub sub: InlineType,
}


// sup is A <sup> is a simple inline text to be shown in superscript text.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct sup {
	#[serde(rename = "sup")]
	pub sup: InlineType,
}


// del is A <del> is a simple inline text to be shown in deleted text
//             within a modification.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct del {
	#[serde(rename = "del")]
	pub del: InlineType,
}


// ins is An <ins> is a simple inline tag to be used to show inserted text
//             within a modification.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct ins {
	#[serde(rename = "ins")]
	pub ins: InlineType,
}


// bill is A <bill> is a document containing proposed law. When enacted, a
//             <bill> becomes an <statute>.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct bill {
	#[serde(rename = "bill")]
	pub bill: LawDocType,
}


// statute is An <statute> is a document containing an enacted bill.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct statute {
	#[serde(rename = "statute")]
	pub statute: LawDocType,
}


// resolution is A <resolution> is a simple resolution, joint resolution, or concurrent
//             resolution, as those terms are defined by the U.S. Congress.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct resolution {
	#[serde(rename = "resolution")]
	pub resolution: LawDocType,
}


// amendment is An <amendment> is a document containing a pre-enactment stage amendment.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct amendment {
	#[serde(rename = "amendment")]
	pub amendment: LawDocType,
}


// usc_doc is A <uscDoc> is a document containing a title or appendix of the
//             U.S. Code.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct usc_doc {
	#[serde(rename = "uscDoc")]
	pub usc_doc: LawDocType,
}


// doc_number is The <docNumber> is a property that contains a numeric designation
//             assigned to this document. The document number should not contain
//             any document prefix. Use the <docType> for the prefix.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct doc_number {
	#[serde(rename = "docNumber")]
	pub doc_number: PropertyType,
}


// doc_publication_name is The <docPublicationName> is a property used to record the name of
//             the publication that this document is part of. The values of the
//             <docPublicationName> are not defined.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct doc_publication_name {
	#[serde(rename = "docPublicationName")]
	pub doc_publication_name: PropertyType,
}


// doc_release_point is The <docReleasePoint> is a property used to record the point the document
//             was released. The values of the doc status are not defined.  For a USC title,
//             this may be the Public Law number that the title is updated through.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct doc_release_point {
	#[serde(rename = "docReleasePoint")]
	pub doc_release_point: PropertyType,
}


// doc_title is A <docTitle> is a statement that precedes the long title in legislation. The short title is declared in the
//             first clause of a bill and is tagged in that location using the
//             <shortTitle> tag.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct doc_title {
	#[serde(rename = "docTitle")]
	pub doc_title: StatementType,
}


// long_title is A <longTitle> is a statement that sets out the purposes of the bill
//             in general terms.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct long_title {
	#[serde(rename = "longTitle")]
	pub long_title: StatementType,
}


// short_title is The <shortTitle> element is used to surround the short title when it
//             is first defined, usually in the first clause of the bill. Note
//             that the <shortTitle> element is to be used in this case rather than
//             the <docTitle> element.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct short_title {
	#[serde(rename = "shortTitle")]
	pub short_title: InlineType,
}


// term is A <term> is always defined within a definition. The <term> element
//             surrounds the words for the term being defined. It is quite possible
//             for multiple <term> elements to be specified within a definition.
//             When a <term> is the words, in the alternate language, then the
//             xml:lang attribute must be used. <term> elements can also be used
//             for synonyms or near-synonyms which are also specified within the
//             definition.
// 
//             There are two ways in which defined terms are presented. The modern
//             form is to present the term in bold and/or italic. The older form
//             is to present the terms bounded by open and close double quotes. In
//             all cases, the term (excluding the quotation marks) should be bound
//             with the <term> element. The presentation should be determined based
//             on the use of the @class and the @style attributes (TBD). It is
//             important that the semantics be captured in the tags and that the
//             presentation be separated and isolated to the styling attributes.
// 
//             Notes:
// 
//             (1) In some cases, a term from the opposite language may be defined
//             without a term in the primary language and the term will be used as
//             such in the legislation despite being in the opposite language.
// 
//             (2) It is possible that a <term> appear multiple times within a
//             definition and be identified as a <term> (along with the
//             corresponding interpretation) each time the term appears.
// 
//             (3) In some rare cases, a term may be defined to include the open
//             and close quotes. In newer presentation forms, the term with the
//             quotation marks will be found within the bold and/or italics while
//             in older presentation forms, the term will show as a pair of open
//             and a pair of close quotation marks. In that case, the inner
//             quotation marks should be treated as part of the term itself.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct term {
	#[serde(rename = "term")]
	pub term: InlineType,
}


// preliminary is A <preliminary> level is used to create a hierarchical region
//             of the main document consisting of preliminary clauses that
//             are outside of the main document hierarchy.
// 
//             When naming a preliminary level, the case-sensitive prefix "prelim".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct preliminary {
	#[serde(rename = "preliminary")]
	pub preliminary: LevelType,
}


// title is A <title> is the top hierarchical level of a legislative document.
// 
//             When naming a title, use the case-sensitive prefix "t".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct title {
	#[serde(rename = "title")]
	pub title: LevelType,
}


// subtitle is A <subtitle> is a hierarchical level of a legislative document.
// 
//             When naming a subtitle, use the case-sensitive prefix "st".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subtitle {
	#[serde(rename = "subtitle")]
	pub subtitle: LevelType,
}


// part is A <part> is a hierarchical level of a legislative document.
// 
//             When naming a part, use the case-sensitive prefix "p".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct part {
	#[serde(rename = "part")]
	pub part: LevelType,
}


// subpart is A <subpart> is a hierarchical level of a legislative document.
// 
//             When naming a subpart, use the case-sensitive prefix "sp".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subpart {
	#[serde(rename = "subpart")]
	pub subpart: LevelType,
}


// division is A <division> is a hierarchical level of a legislative document.
// 
//             When naming a Division, use the case-sensitive prefix "d".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct division {
	#[serde(rename = "division")]
	pub division: LevelType,
}


// subdivision is A <subdivision> is a hierarchical level of a legislative document.
// 
//             When naming a subdivision, use the case-sensitive prefix "sd".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subdivision {
	#[serde(rename = "subdivision")]
	pub subdivision: LevelType,
}


// chapter is A <chapter> is a hierarchical of a legislative document.
// 
//             When naming a chapter, use the case-sensitive prefix "c".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct chapter {
	#[serde(rename = "chapter")]
	pub chapter: LevelType,
}


// subchapter is A <subchapter> is a hierarchical level of a legislative document.
// 
//             When naming a subchapter, use the case-sensitive prefix "sc".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subchapter {
	#[serde(rename = "subchapter")]
	pub subchapter: LevelType,
}


// article is An <article> is a used in bills.
// 
//             When naming an article, use the case-sensitive prefix "a".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct article {
	#[serde(rename = "article")]
	pub article: LevelType,
}


// subarticle is A <subarticle> is used in bills.
// 
//             When naming a subarticle, use the case-sensitive prefix "sa".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subarticle {
	#[serde(rename = "subarticle")]
	pub subarticle: LevelType,
}


// section is A <section> is the primary hierarchical level in a USC Title or a bill.
// 
//             When naming a section, use the case-sensitive prefix "s".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct section {
	#[serde(rename = "section")]
	pub section: LevelType,
}


// subsection is A <subsection> is an optional hierarchical level below a section.
//             Subsections are usually numbered with lower-case letters.
// 
//             When naming a subsection, use the case-sensitive prefix "ss".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subsection {
	#[serde(rename = "subsection")]
	pub subsection: LevelType,
}


// paragraph is A <paragraph> is a numbered level usually found below a
//             subsection in the document hierarchy. Paragraphs are
//             usually numbered with Arabic numbers.
// 
//             When naming a paragraph, use the case-sensitive prefix "p".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct paragraph {
	#[serde(rename = "paragraph")]
	pub paragraph: LevelType,
}


// subparagraph is A <subparagraph> is a level below a paragraph in the document
//             hierarchy. Subparagraphs are usually numbered with upper-case
//             letters.
// 
//             When naming a subparagraph, use the case-sensitive prefix "sp".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subparagraph {
	#[serde(rename = "subparagraph")]
	pub subparagraph: LevelType,
}


// clause is A <clause> is an optional below-section hierarchical level.
//             Clauses are usually numbered with lower-case Roman numerals.
// 
//             When naming a subclause, use the case-sensitive prefix "sc".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct clause {
	#[serde(rename = "clause")]
	pub clause: LevelType,
}


// subclause is A <subclause> is an optional hierarchical level below a clause.
//             Subclauses are usually numbered with upper-case Roman numerals.
// 
//             When naming a subclause, use the case-sensitive prefix "sc".
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subclause {
	#[serde(rename = "subclause")]
	pub subclause: LevelType,
}


// item is An <item> is a level usually below a subclause in the document
//             hierarchy. Items are usually numbered with double lower-case
//             letters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct item {
	#[serde(rename = "item")]
	pub item: LevelType,
}


// subitem is A <subitem> is a level below an item in the document
//             hierarchy. Subitems are usually numbered with double upper-case
//             letters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subitem {
	#[serde(rename = "subitem")]
	pub subitem: LevelType,
}


// subsubitem is A <subsubitem> is a level below a subitem in the document
//             hierarchy. Subsubitems are usually numbered with triple lower-case
//             letters.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct subsubitem {
	#[serde(rename = "subsubitem")]
	pub subsubitem: LevelType,
}


// def is A <def> defines a term. It contains one or more <term> elements
//             identifying the term being defined as well as the text describing
//             the term. It is customary for the <term> to be identified in both
//             languages. In the case where the term is for the opposite language,
//             then the xml:lang attribute should be set for the term expressed in
//             the opposite language. In some cases, closely related other terms
//             might also be identified within the text of the definition and will
//             also be identified with the <term> element..
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct def {
	#[serde(rename = "def")]
	pub def: TextType,
}


// chapeau is Use a <chapeau> whenever there is introductory text that comes
//             before lower levels in a level hierarchy and the text alone is not
//             permitted by the content model.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct chapeau {
	#[serde(rename = "chapeau")]
	pub chapeau: TextType,
}


// continuation is Use a <continuation> for interstitial text or whenever there is
//             final text that comes after lower levels in a level hierarchy and
//             the text alone is not permitted by the content model.
// 
//             Be careful not to confuse continuation text with a proviso, which has
//             a separate tag.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct continuation {
	#[serde(rename = "continuation")]
	pub continuation: TextType,
}


// proviso is A <proviso> is a paragraph that states conditions relating to the
//             law it is related to. A proviso generally begins with "Provided that"
//             or just "Provided". Proviso can contain their own
//             complex structure including sandwich structures. When referencing
//             into numbered parts of a proviso, a "proviso" level is added to
//             the reference. If there are multiple provisos within a single
//             parent, then those provisos should be named.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct proviso {
	#[serde(rename = "proviso")]
	pub proviso: TextType,
}


// amending_formula is An <amendingFormula> element is an instruction used when defining an amendment
//             to legislation or proposed legislation.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct amending_formula {
	#[serde(rename = "amendingFormula")]
	pub amending_formula: InstructionType,
}


// source_credit is A <sourceCredit> is a note included to indicate the source of a
//             provision. It usually will contain a reference to the source of the
//             provision and the Statute(s) that have affected it. Source credits are
//             usually set out in parenthesis. The surrounding
//             parenthesis are shown in the text - they must
//             not be automatically added.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct source_credit {
	#[serde(rename = "sourceCredit")]
	pub source_credit: NoteType,
}


// statutory_note is An <statutoryNote> is a note that becomes part of the law.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct statutory_note {
	#[serde(rename = "statutoryNote")]
	pub statutory_note: NoteType,
}


// editorial_note is An <editorialNote> is a note included for editorial purposes only. While
//             present in the text of the document as printed, it is not a part of
//             the law. Editorial notes are often used to record where provisions
//             have been omitted or other changes have been made.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct editorial_note {
	#[serde(rename = "editorialNote")]
	pub editorial_note: NoteType,
}


// change_note is A <changeNote> is a note that records a non-substantive change that
//             has been made to the document. Usually
//             change notes are set out in square brackets and these must be set out in
//             the text and must not be automatically added.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct change_note {
	#[serde(rename = "changeNote")]
	pub change_note: NoteType,
}


// made is The signatures of the people making the legislation.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct made {
	#[serde(rename = "made")]
	pub made: SignaturesType,
}


// approved is The signature of the people approving the document.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct approved {
	#[serde(rename = "approved")]
	pub approved: SignaturesType,
}


// schedule is A <schedule> is an appendix to a bill or other document.
//             It contains a wide variety of content and the containment model is
//             consequently quite loose. A <schedule> is often a list of numbered items,
//             sometimes arranged in columns. Sometimes a schedule is a list of
//             consequential amendments. Schedules can also be tables or documents
//             defined externally such as extradition treaties or trade agreements.
//             Schedules are sometimes printed in a landscape rather that portrait
//             orientation.
// 
//             In order to support the wide variety of content types, it is possible
//             to embed arbitrary HTML content in a <content> element within a
//             schedule.
#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct schedule {
	#[serde(rename = "schedule")]
	pub schedule: AppendixType,
}
