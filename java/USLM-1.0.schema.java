// Code generated by xgen. DO NOT EDIT.

package schema;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;

// DateSimpleType is The date simple type unifies both date and time formats and allows
//             a date to be specified as either a day or a time in a day. This is
//             to allow situations where the law becomes effective based on another
//             time zone.
public class DateSimpleType {
	@XmlElement(required = true)
	protected String DateTime;
	@XmlElement(required = true)
	protected String Date;
}

// OccurrenceSimpleType is The occurrence simple type specifies which occurrence is affected
//             by an action when amending. An occurence can be either a positive
//             integer or a value from the choice enumeration such as "all" for
//             all occurrences or "last" for the last occurrence.
public class OccurrenceSimpleType {
	@XmlElement(required = true)
	protected ChoiceEnum ChoiceEnum;
	@XmlElement(required = true)
	protected Integer PositiveInteger;
}

// ShortStringSimpleType is A simple string with not more than 32 characters.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "ShortStringSimpleType")
public class ShortStringSimpleType {
	protected String ShortStringSimpleType;
}

// MediumStringSimpleType is A simple string with not more than 128 characters.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "MediumStringSimpleType")
public class MediumStringSimpleType {
	protected String MediumStringSimpleType;
}

// LongStringSimpleType is A simple string with not more than 1024 characters.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "LongStringSimpleType")
public class LongStringSimpleType {
	protected String LongStringSimpleType;
}

// ChoiceEnum is The choice enumeration is used to enumerate some textual values for
//             use with the occurrence simple type defined above.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "ChoiceEnum")
public class ChoiceEnum {
	protected String ChoiceEnum;
}

// PropertyTypeEnum is The property  type enumeration allows a property to be given a
//             type specification. If the @type attribute is not specified, then
//             the default type is "string".
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "PropertyTypeEnum")
public class PropertyTypeEnum {
	protected String PropertyTypeEnum;
}

// SetTypeEnum is A "res" is a resource, such as a person, place, or thing and
//                   the properties enclosed within the set describe it.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "SetTypeEnum")
public class SetTypeEnum {
	protected String SetTypeEnum;
}

// StatusEnum is A "unknown" status indicates that the status is not known.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "StatusEnum")
public class StatusEnum {
	protected String StatusEnum;
}

// ActionTypeEnum is The "delete" action removes text from a proposed provision to
//                   the law.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "ActionTypeEnum")
public class ActionTypeEnum {
	protected String ActionTypeEnum;
}

// PositionEnum is The position enumeration is used with references found within
//             amendments when it is necessary to specify a position relative to an
//             item rather than when referencing the item itself.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "PositionEnum")
public class PositionEnum {
	protected String PositionEnum;
}

// OrientationEnum is The orientation enumeration is used specify how an item should be
//             oriented in the printed form. The orientation can be specified
//             for any content item or for any appendix item, including a
//             schedule.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "OrientationEnum")
public class OrientationEnum {
	protected String OrientationEnum;
}

// NoteTypeEnum is Notes can be placed inline, as footnotes at the end of the page,
//             as end notes as the end of document, or U.S. Code notes. By default,
//             notes are inline
@XmlAccessorType(XmlAccessType.FIELD)
@XmlAttribute(required = true, name = "NoteTypeEnum")
public class NoteTypeEnum {
	protected String NoteTypeEnum;
}

// IdentificationGroup is Use the @identifier attribute to specify the URL context of the
//                element. Typically, the @identifier will be established on the
//                root element or on any element, such as a <quotedStructure> or
//                <quotedText> element, that changes the context.
// 
//                The @identifier attribute is optional.
public class IdentificationGroup {
	@XmlAttribute(name = "id")
	protected StringAttr Id;
	@XmlAttribute(name = "name")
	protected StringAttr Name;
	@XmlAttribute(name = "temporalId")
	protected StringAttr TemporalId;
	@XmlAttribute(name = "identifier")
	protected StringAttr Identifier;
}

// ClassificationGroup is The @style attribute is used to specify CSS attributes that
//                override the default styles defined for an element or an element
//                class. The current loose-leaf publication standards should be
//                specified using an external style sheet and the use of the @style
//                attribute should be reserved for exception cases where the
//                default presentation must be overridden.
public class ClassificationGroup {
	@XmlAttribute(name = "role")
	protected StringAttr Role;
	@XmlAttribute(name = "class")
	protected StringAttr Class;
	@XmlAttribute(name = "style")
	protected StringAttr Style;
}

// AnnotationGroup is The @codificationTip is for internal use by the OLRC.
public class AnnotationGroup {
	@XmlAttribute(name = "note")
	protected StringAttr Note;
	@XmlAttribute(name = "alt")
	protected StringAttr Alt;
	@XmlAttribute(name = "meta")
	protected StringAttr Meta;
	@XmlAttribute(name = "misc")
	protected StringAttr Misc;
	@XmlAttribute(name = "draftingTip")
	protected StringAttr DraftingTip;
	@XmlAttribute(name = "codificationTip")
	protected StringAttr CodificationTip;
}

// DescriptionGroup is The @sortOrder attribute is used to specify a sorting order for
//                a list of items, when that sort order is not the document
//                sequence. The @sortOrder value must be specified as a positive
//                integer. This attribute should rarely be used.
public class DescriptionGroup {
	@XmlAttribute(name = "title")
	protected StringAttr Title;
	@XmlAttribute(name = "brief")
	protected StringAttr Brief;
	@XmlAttribute(name = "sortOrder")
	protected IntegerAttr SortOrder;
}

// ReferenceGroup is The @portion attribute is used, in conjunction with the @idref
//                attribute, when only a portion of the referenced item is being
//                affected. The value of @portion is an additional part to append
//                to the URL, with a "/" separator to identify the item affected.
//                Do not include a leading "/" in the @portion value.
public class ReferenceGroup {
	@XmlAttribute(name = "href")
	protected QNameAttr Href;
	@XmlAttribute(name = "idref")
	protected StringAttr Idref;
	@XmlAttribute(name = "portion")
	protected StringAttr Portion;
}

// AmendingGroup is The @posCount attribute is used to specify the number of
//                occurrences of the @posText to seek out when establishing the
//                context.
public class AmendingGroup {
	@XmlAttribute(name = "pos")
	protected StringAttr Pos;
	@XmlAttribute(name = "posText")
	protected StringAttr PosText;
	@XmlAttribute(name = "posCount")
	protected IntegerAttr PosCount;
}

// LinkGroup is The @src attribute is a URL that points to an item to be included
//                in the published document. Unlike an @href attribute, a @src
//                attribute can be any normal URL and can be relative or absolute.
public class LinkGroup {
	@XmlAttribute(name = "src")
	protected QNameAttr Src;
}

// ValueGroup is The @endValue attribute is used for the upper end of a value
//             range.
public class ValueGroup {
	@XmlAttribute(name = "value")
	protected StringAttr Value;
	@XmlAttribute(name = "startValue")
	protected StringAttr StartValue;
	@XmlAttribute(name = "endValue")
	protected StringAttr EndValue;
}

// NoteGroup is Set the @topic attribute to a string value in order
//                      to categorize the note or group of notes. An open,
//                      but enumerated, list of string values should be used.
//                      Using a fixed list of values will better aid in
//                      categorization of notes later.
public class NoteGroup {
	@XmlAttribute(name = "type")
	protected StringAttr Type;
	@XmlAttribute(name = "topic")
	protected StringAttr Topic;
}

// DateGroup is The @endDate attribute is used for the ending date of a date
//                range.
public class DateGroup {
	@XmlAttribute(name = "date")
	protected DateSimpleTypeAttr Date;
	@XmlAttribute(name = "startDate")
	protected DateSimpleTypeAttr StartDate;
	@XmlAttribute(name = "endDate")
	protected DateSimpleTypeAttr EndDate;
}

// VersioningGroup is The @partial attribute is used, in conjunction with the
//                @status attribute to indicate that the status is not fully
//                applied.
public class VersioningGroup {
	@XmlAttribute(name = "startPeriod")
	protected DateSimpleTypeAttr StartPeriod;
	@XmlAttribute(name = "endPeriod")
	protected DateSimpleTypeAttr EndPeriod;
	@XmlAttribute(name = "status")
	protected StringAttr Status;
	@XmlAttribute(name = "partial")
	protected BooleanAttr Partial;
}

// ActionGroup is The @commencementDate attribute specifies the date upon which the
//                action is to be applied.
public class ActionGroup {
	@XmlAttribute(name = "type")
	protected StringAttr Type;
	@XmlAttribute(name = "occurrence")
	protected OccurrenceSimpleTypeAttr Occurrence;
	@XmlAttribute(name = "commencementDate")
	protected DateSimpleTypeAttr CommencementDate;
}

// CellGroup is The @leaders attribute specifies whether leaders should be
//             shown either trailing or following the text content. The character
//             included as the value is the character used to render the leaders.
// 
//             Use the CSS text-align character to position the text. If you
//             align the text to the left, then the leaders will show to the
//             right and if you align the text to the right, then the leaders
//             will show to the left.
public class CellGroup {
	@XmlAttribute(name = "colspan")
	protected IntegerAttr Colspan;
	@XmlAttribute(name = "rowspan")
	protected IntegerAttr Rowspan;
	@XmlAttribute(name = "leaders")
	protected StringAttr Leaders;
}

// BaseType is The base type defines the most general element, specifying the
//             attributes which can be found on all elements - specifically
//             attributes belonging to the identification, classification, and
//             annotation groups.
// 
//             The base type is defined as an abstract type and elements cannot
//             be declared based on it.
public class BaseType {
	@XmlElement(required = true)
	protected IdentificationGroup IdentificationGroup;
	@XmlElement(required = true)
	protected ClassificationGroup ClassificationGroup;
	@XmlElement(required = true)
	protected AnnotationGroup AnnotationGroup;
	@XmlElement(required = true)
	protected VersioningGroup VersioningGroup;
	@XmlValue
	protected String value;
}

// BaseBlockType is The base block type is a variant of the base type, but having a
//             content structure to support block level children - elements
//             but no text.
public class BaseBlockType {
	@XmlElement(required = true)
	protected IdentificationGroup IdentificationGroup;
	@XmlElement(required = true)
	protected ClassificationGroup ClassificationGroup;
	@XmlElement(required = true)
	protected AnnotationGroup AnnotationGroup;
	@XmlElement(required = true)
	protected VersioningGroup VersioningGroup;
}

// BaseContentType is The base content type is a variant of the base type, but having
//             a very open content model including text.
public class BaseContentType {
	@XmlElement(required = true)
	protected IdentificationGroup IdentificationGroup;
	@XmlElement(required = true)
	protected ClassificationGroup ClassificationGroup;
	@XmlElement(required = true)
	protected AnnotationGroup AnnotationGroup;
	@XmlElement(required = true)
	protected VersioningGroup VersioningGroup;
}

// MarkerType is The marker type is a restriction of the base type to an element
//             without content.
public class MarkerType {
}

// InlineType is The inline type is a extension of the base type to text content or
//             other inline elements.
public class InlineType extends BaseContentType  {
	@XmlElement(required = true, name = "marker")
	protected List<MarkerType> Marker;
	@XmlElement(required = true, name = "inline")
	protected List<InlineType> Inline;
}

// BlockType is The block type is a extension of the base type to content
//             consisting of only elements.
public class BlockType extends BaseBlockType  {
}

// TextType is The text type is a broad base type allowing any content.
public class TextType extends BaseContentType  {
}

// ContentType is The content type is a broad base type allowing any content.
public class ContentType extends BaseContentType  {
	@XmlAttribute(name = "orientation")
	protected String OrientationAttr;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "marker")
public class Marker {
	protected MarkerType Marker;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "inline")
public class Inline {
	protected InlineType Inline;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "block")
public class Block {
	protected BlockType Block;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "content")
public class Content {
	protected ContentType Content;
}

// LawDocType is In addition to the main part of the document, a document
//                         may have one or more appendices such as schedules or
//                         explanatory memorandums/notes. These appendices can
//                         either be inline documents or the can be external
//                         referenced documents.
public class LawDocType extends BaseBlockType  {
	@XmlElement(required = true, name = "meta")
	protected MetaType Meta;
	@XmlElement(name = "main")
	protected MainType Main;
	@XmlElement(required = true, name = "block")
	protected List<BlockType> Block;
	@XmlElement(required = true, name = "appendix")
	protected List<AppendixType> Appendix;
}

// GenericDocType is In addition to the content part of the document, a document
//                         may have one or more appendices.
public class GenericDocType extends BaseBlockType  {
	@XmlElement(required = true, name = "meta")
	protected MetaType Meta;
	@XmlElement(required = true, name = "content")
	protected ContentType Content;
	@XmlElement(name = "appendix")
	protected List<AppendixType> Appendix;
}

// MetaType is Properties can be grouped into sets. These set can
//                         be used to represent something like a series of events,
//                         a person, or another other object related to the
//                         document.
public class MetaType extends BaseBlockType  {
	@XmlElement(required = true, name = "property")
	protected List<PropertyType> Property;
	@XmlElement(required = true, name = "set")
	protected List<SetType> Set;
}

// PropertyType is A property can represent a pointer to either an external
//                   document or an element within the document.
// 
//                   You can use a ref to create a pointer to an endnote or a
//                   footnote. In that case, the ref text will be the endnote or
//                   footnote indicator as seen in "<ref idref="fn000001">â€ </ref>"
//                   where the dagger is the indicator. An endnote or footnote
//                   reference should always use the @idref attribute to point to
//                   an endnote or a footnote within the document.
public class PropertyType extends InlineType  {
	@XmlElement(required = true)
	protected DateGroup DateGroup;
	@XmlElement(required = true)
	protected ValueGroup ValueGroup;
	@XmlElement(required = true)
	protected ReferenceGroup ReferenceGroup;
	@XmlAttribute(name = "type")
	protected String TypeAttr;
}

// SetType is A set can contain 0 or more sets.
public class SetType extends BaseBlockType  {
	@XmlAttribute(name = "type")
	protected String TypeAttr;
	@XmlElement(required = true, name = "property")
	protected List<PropertyType> Property;
	@XmlElement(required = true, name = "set")
	protected List<SetType> Set;
}

// TocType is The items in a table of contents can be arranged in
//                         a tabular fashion by surrounding the items in a layout.
//                         When a layout is specified, use <column> elements
//                         within each <tocItem> to indicate specific columns.
public class TocType extends BaseBlockType  {
	@XmlAttribute(name = "generate")
	protected Boolean GenerateAttr;
	protected HeadingStructure HeadingStructure;
	@XmlElement(required = true, name = "tocItem")
	protected List<TocItemType> TocItem;
	@XmlElement(required = true, name = "layout")
	protected List<LayoutType> Layout;
}

// TocItemType is Use the description group to record the number and title in the
//                   table of contents as metadata.
public class TocItemType extends BaseBlockType  {
	@XmlElement(required = true)
	protected DescriptionGroup DescriptionGroup;
	protected HeadingStructure HeadingStructure;
	@XmlElement(name = "tocItem")
	protected List<TocItemType> TocItem;
	@XmlElement(required = true, name = "content")
	protected List<ContentType> Content;
}

// MainType is The document is permitted to be empty to allow for the
//                         case when the document is newly created and still in a
//                         drafting state.
public class MainType {
	protected List<NoteStructure> NoteStructure;
	protected PreambleStructure PreambleStructure;
	protected LevelStructure LevelStructure;
	@XmlElement(required = true, name = "property")
	protected List<PropertyType> Property;
	@XmlElement(required = true, name = "block")
	protected List<BlockType> Block;
	@XmlElement(required = true, name = "statement")
	protected List<StatementType> Statement;
	@XmlElement(required = true, name = "toc")
	protected List<TocType> Toc;
}

// StatementType is The attributes of the description group can be used to
//                   record a number and title for a statement for use when
//                   generating a table of contents.
public class StatementType extends BaseContentType  {
	@XmlElement(required = true)
	protected DescriptionGroup DescriptionGroup;
	@XmlElement(required = true, name = "marker")
	protected List<MarkerType> Marker;
	@XmlElement(required = true, name = "inline")
	protected List<InlineType> Inline;
	@XmlElement(required = true, name = "block")
	protected List<BlockType> Block;
	@XmlElement(required = true, name = "text")
	protected List<TextType> Text;
	@XmlElement(required = true, name = "content")
	protected List<ContentType> Content;
	@XmlElement(required = true, name = "level")
	protected List<LevelType> Level;
}

// PreambleType is Attributes from the description group may be used to
//                      attach information to the preamble for use in generating
//                      a table of contents.
public class PreambleType extends BaseBlockType  {
	@XmlElement(required = true)
	protected DescriptionGroup DescriptionGroup;
	protected HeadingStructure HeadingStructure;
	protected List<RecitalStructure> RecitalStructure;
	@XmlElement(name = "enactingFormula")
	protected StatementType EnactingFormula;
}

// LevelType is Use the description group to record information in the
//                      attributes to be used when generating the table of contents.
public class LevelType extends BaseBlockType  {
	@XmlElement(required = true)
	protected DescriptionGroup DescriptionGroup;
	protected NumStructure NumStructure;
	protected HeadingStructure HeadingStructure;
	protected List<TocStructure> TocStructure;
	protected LevelStructure LevelStructure;
}

// NumType is Use the @value attribute to record a normalized value of
//                      the <num> content. When the text content represents a
//                      range of values, use the @beginValue and @endValue
//                      attributes to record the range.
public class NumType extends InlineType  {
	@XmlElement(required = true)
	protected ValueGroup ValueGroup;
}

// HeadingType is The heading type is used to define heading and subheadings for
//             levels and other structured items. Often a heading will follow
//             a number.
public class HeadingType extends ContentType  {
}

// InstructionType is A quoted structure may be associated with an
//                            action (by position) as part of the processing
//                            action.
public class InstructionType extends BaseContentType  {
	@XmlElement(required = true, name = "ref")
	protected RefType Ref;
	@XmlElement(required = true, name = "inline")
	protected List<InlineType> Inline;
	@XmlElement(required = true, name = "marker")
	protected List<MarkerType> Marker;
	@XmlElement(required = true, name = "action")
	protected List<ActionType> Action;
	@XmlElement(required = true, name = "level")
	protected List<LevelType> Level;
	@XmlElement(required = true, name = "quotedText")
	protected List<QuotedTextType> QuotedText;
	@XmlElement(required = true, name = "quotedContent")
	protected List<QuotedContentType> QuotedContent;
}

// ActionType is Use the @action attribute to describe the action being taken.
public class ActionType extends InlineType  {
	@XmlElement(required = true)
	protected ReferenceGroup ReferenceGroup;
	@XmlElement(required = true)
	protected AmendingGroup AmendingGroup;
	@XmlElement(required = true)
	protected ActionGroup ActionGroup;
}

// NotesType is You can use the @type attribute to position the notes
//                      and the @topic attribute to categorize the notes.
public class NotesType extends BaseBlockType  {
	@XmlElement(required = true)
	protected NoteGroup NoteGroup;
	@XmlElement(name = "heading")
	protected HeadingType Heading;
	@XmlElement(name = "subheading")
	protected List<HeadingType> Subheading;
	@XmlElement(required = true, name = "note")
	protected List<NoteType> Note;
	@XmlElement(required = true, name = "layout")
	protected LayoutType Layout;
}

// NoteType is You can use the @date to associate dates to your notes.
//                      This can be used to generate alerts.
public class NoteType extends ContentType  {
	@XmlElement(required = true)
	protected NoteGroup NoteGroup;
	@XmlElement(required = true)
	protected DateGroup DateGroup;
}

// AppendixType is If an <appendix> is to be included by reference, use the
//                      @src attribute with a normal URL to point to the document
//                      to be included.
public class AppendixType extends BaseBlockType  {
	@XmlElement(required = true)
	protected DescriptionGroup DescriptionGroup;
	@XmlElement(required = true)
	protected LinkGroup LinkGroup;
	@XmlAttribute(name = "orientation")
	protected String OrientationAttr;
	protected NumStructure NumStructure;
	protected HeadingStructure HeadingStructure;
	protected TocStructure TocStructure;
	protected LevelStructure LevelStructure;
	@XmlElement(required = true, name = "block")
	protected BlockType Block;
}

// SignaturesType is Defines a block for a collection of signatures. An opening paragraph
//             is permitted as well as an ending date. In some cases, the date may
//             appear within the opening paragraph.
// 
//             The signatures may either be specified serially in a grid-like
//             layout.
public class SignaturesType {
	@XmlElement(name = "p")
	protected PType P;
	@XmlElement(required = true, name = "signature")
	protected List<SignatureType> Signature;
	@XmlElement(required = true, name = "layout")
	protected LayoutType Layout;
	@XmlElement(name = "date")
	protected String Date;
}

// Name ...
public class Name {
}

// Role ...
public class Role {
}

// Affiliation ...
public class Affiliation {
}

// SignatureType is Defines a basic signature element comprising a name and optionally
//             the person's role, their affiliation, and a date. All fields can be
//             defined to include either an @href or an @idref to point to an
//             identifying resource that describes the person, their role, and
//             their affiliation.
public class SignatureType {
	@XmlElement(required = true, name = "name")
	protected Name Name;
	@XmlElement(name = "role")
	protected Role Role;
	@XmlElement(name = "affiliation")
	protected Affiliation Affiliation;
	@XmlElement(name = "date")
	protected String Date;
}

// RefType is Use the @pos and other attributes to describe
//                      what or where is being affected.
// 
//                      The attributes in the amending group should only be used
//                      for references or actions within an amending instruction.
public class RefType extends PropertyType  {
	@XmlElement(required = true)
	protected AmendingGroup AmendingGroup;
}

// DateType is Use the @date attribute to record a normalized value of the
//                      date according to ISO 8601.
public class DateType {
	@XmlElement(required = true)
	protected DateGroup DateGroup;
}

// QuotedTextType is A quoted text type is an extraction of simple text from another
//             source or origin. If the quoted text is to have literal quotes
//             surrounding it, then those characters must be included in the text
//             surrounding the quoted text and not within it.
// 
//             Quoted text is seen in amendments or modifications.
// 
//             Use the @identifier attribute to establish the referencing context
//             of the quoted text.
public class QuotedTextType extends InlineType  {
	@XmlAttribute(name = "origin")
	protected QName OriginAttr;
}

// QuotedContentType is A quotedContentType is used for an extraction of potentially structured
//             text (text with XML elements) from another source or origin.
// 
//             Quoted content is seen in USC Notes, amendments, and modifications.
// 
//             Use the @identifier attribute to establish the referencing context
//             of the quoted structure
public class QuotedContentType extends ContentType  {
	@XmlAttribute(name = "origin")
	protected QName OriginAttr;
}

// NoteStructure ...
public class NoteStructure {
	@XmlElement(required = true, name = "note")
	protected NoteType Note;
	@XmlElement(required = true, name = "notes")
	protected NotesType Notes;
}

// NumStructure ...
public class NumStructure {
	@XmlElement(required = true, name = "num")
	protected List<NumType> Num;
	protected List<NoteStructure> NoteStructure;
}

// HeadingStructure ...
public class HeadingStructure {
	@XmlElement(required = true, name = "heading")
	protected List<HeadingType> Heading;
	@XmlElement(required = true, name = "subheading")
	protected List<HeadingType> Subheading;
	protected List<NoteStructure> NoteStructure;
}

// TocStructure ...
public class TocStructure {
	@XmlElement(required = true, name = "toc")
	protected TocType Toc;
	protected List<NoteStructure> NoteStructure;
}

// StatementStructure ...
public class StatementStructure {
	@XmlElement(required = true, name = "statement")
	protected StatementType Statement;
	protected List<NoteStructure> NoteStructure;
}

// RecitalStructure ...
public class RecitalStructure {
	@XmlElement(required = true, name = "recital")
	protected StatementType Recital;
	protected List<NoteStructure> NoteStructure;
}

// PreambleStructure ...
public class PreambleStructure {
	@XmlElement(required = true, name = "preamble")
	protected PreambleType Preamble;
	@XmlElement(required = true, name = "enactingFormula")
	protected StatementType EnactingFormula;
	protected List<NoteStructure> NoteStructure;
}

// LevelStructure ...
public class LevelStructure {
	@XmlElement(required = true, name = "instruction")
	protected List<InstructionType> Instruction;
	@XmlElement(required = true, name = "content")
	protected List<ContentType> Content;
	@XmlElement(required = true, name = "text")
	protected List<TextType> Text;
	@XmlElement(required = true, name = "level")
	protected List<LevelType> Level;
	@XmlElement(required = true, name = "crossHeading")
	protected List<HeadingType> CrossHeading;
	protected List<NoteStructure> NoteStructure;
	protected List<NoteStructure> NoteStructure;
	protected List<NoteStructure> NoteStructure;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "lawDoc")
public class LawDoc {
	protected LawDocType LawDoc;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "document")
public class Document {
	protected GenericDocType Document;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "meta")
public class Meta {
	protected MetaType Meta;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "property")
public class Property {
	protected PropertyType Property;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "set")
public class Set {
	protected SetType Set;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "toc")
public class Toc {
	protected TocType Toc;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "tocItem")
public class TocItem {
	protected TocItemType TocItem;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "main")
public class Main {
	protected MainType Main;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "statement")
public class Statement {
	protected StatementType Statement;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "preamble")
public class Preamble {
	protected PreambleType Preamble;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "recital")
public class Recital {
	protected StatementType Recital;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "enactingFormula")
public class EnactingFormula {
	protected StatementType EnactingFormula;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "level")
public class Level {
	protected LevelType Level;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "num")
public class Num {
	protected NumType Num;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "text")
public class Text {
	protected TextType Text;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "heading")
public class Heading {
	protected HeadingType Heading;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subheading")
public class Subheading {
	protected HeadingType Subheading;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "crossHeading")
public class CrossHeading {
	protected HeadingType CrossHeading;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "instruction")
public class Instruction {
	protected InstructionType Instruction;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "action")
public class Action {
	protected ActionType Action;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "notes")
public class Notes {
	protected NotesType Notes;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "note")
public class Note {
	protected NoteType Note;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "appendix")
public class Appendix {
	protected AppendixType Appendix;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "signatures")
public class Signatures {
	protected SignaturesType Signatures;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "signature")
public class Signature {
	protected SignatureType Signature;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "ref")
public class Ref {
	protected RefType Ref;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "date")
public class Date {
	protected DateType Date;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "quotedText")
public class QuotedText {
	protected QuotedTextType QuotedText;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "quotedContent")
public class QuotedContent {
	protected QuotedContentType QuotedContent;
}

// LayoutType is A <layout> type can contain various types of elements
//                      as rows including headers, rows, TOC items, blocks,
//                      and contents. All elements, aside from <column> elements,
//                      are treated as rows when found directly within a layout
//                      structure.
public class LayoutType extends BaseBlockType  {
	@XmlAttribute(name = "orientation")
	protected String OrientationAttr;
	protected List<NoteStructure> NoteStructure;
	@XmlElement(required = true, name = "header")
	protected List<RowType> Header;
	@XmlElement(required = true, name = "row")
	protected List<RowType> Row;
	@XmlElement(required = true, name = "tocItem")
	protected List<TocItemType> TocItem;
	@XmlElement(required = true, name = "block")
	protected List<BlockType> Block;
	@XmlElement(required = true, name = "content")
	protected List<ContentType> Content;
}

// RowType is A row contains one or more column cells.
public class RowType extends BaseBlockType  {
	@XmlElement(required = true, name = "column")
	protected List<ColumnType> Column;
}

// ColumnType is Use the elements of the cell group to specify
//                      the row and column spans.
public class ColumnType extends ContentType  {
	@XmlElement(required = true)
	protected CellGroup CellGroup;
}

// PType is A "P" type is a simple unnumbered paragraph. As a <content>
//             element, it can contain a wide range of text and elements.
public class PType extends ContentType  {
}

// BrType is A break type is simple marker element denoting a line break.
public class BrType extends MarkerType  {
}

// ImgType is An image type is a simple marker element denoting where a graphic
//             image is to be inserted.
public class ImgType extends MarkerType  {
	@XmlElement(required = true)
	protected LinkGroup LinkGroup;
	@XmlAttribute(name = "orientation")
	protected String OrientationAttr;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "layout")
public class Layout {
	protected LayoutType Layout;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "header")
public class Header {
	protected RowType Header;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "row")
public class Row {
	protected RowType Row;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "column")
public class Column {
	protected ColumnType Column;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "p")
public class P {
	protected PType P;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "br")
public class Br {
	protected BrType Br;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "img")
public class Img {
	protected ImgType Img;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "center")
public class Center {
	protected ContentType Center;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "fillIn")
public class FillIn {
	protected ContentType FillIn;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "checkBox")
public class CheckBox {
	protected ContentType CheckBox;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "b")
public class B {
	protected InlineType B;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "i")
public class I {
	protected InlineType I;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "sub")
public class Sub {
	protected InlineType Sub;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "sup")
public class Sup {
	protected InlineType Sup;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "del")
public class Del {
	protected InlineType Del;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "ins")
public class Ins {
	protected InlineType Ins;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "bill")
public class Bill {
	protected LawDocType Bill;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "statute")
public class Statute {
	protected LawDocType Statute;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "resolution")
public class Resolution {
	protected LawDocType Resolution;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "amendment")
public class Amendment {
	protected LawDocType Amendment;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "uscDoc")
public class UscDoc {
	protected LawDocType UscDoc;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "docNumber")
public class DocNumber {
	protected PropertyType DocNumber;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "docPublicationName")
public class DocPublicationName {
	protected PropertyType DocPublicationName;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "docReleasePoint")
public class DocReleasePoint {
	protected PropertyType DocReleasePoint;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "docTitle")
public class DocTitle {
	protected StatementType DocTitle;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "longTitle")
public class LongTitle {
	protected StatementType LongTitle;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "shortTitle")
public class ShortTitle {
	protected InlineType ShortTitle;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "term")
public class Term {
	protected InlineType Term;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "preliminary")
public class Preliminary {
	protected LevelType Preliminary;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "title")
public class Title {
	protected LevelType Title;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subtitle")
public class Subtitle {
	protected LevelType Subtitle;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "part")
public class Part {
	protected LevelType Part;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subpart")
public class Subpart {
	protected LevelType Subpart;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "division")
public class Division {
	protected LevelType Division;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subdivision")
public class Subdivision {
	protected LevelType Subdivision;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "chapter")
public class Chapter {
	protected LevelType Chapter;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subchapter")
public class Subchapter {
	protected LevelType Subchapter;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "article")
public class Article {
	protected LevelType Article;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subarticle")
public class Subarticle {
	protected LevelType Subarticle;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "section")
public class Section {
	protected LevelType Section;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subsection")
public class Subsection {
	protected LevelType Subsection;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "paragraph")
public class Paragraph {
	protected LevelType Paragraph;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subparagraph")
public class Subparagraph {
	protected LevelType Subparagraph;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "clause")
public class Clause {
	protected LevelType Clause;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subclause")
public class Subclause {
	protected LevelType Subclause;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "item")
public class Item {
	protected LevelType Item;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subitem")
public class Subitem {
	protected LevelType Subitem;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "subsubitem")
public class Subsubitem {
	protected LevelType Subsubitem;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "def")
public class Def {
	protected TextType Def;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "chapeau")
public class Chapeau {
	protected TextType Chapeau;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "continuation")
public class Continuation {
	protected TextType Continuation;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "proviso")
public class Proviso {
	protected TextType Proviso;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "amendingFormula")
public class AmendingFormula {
	protected InstructionType AmendingFormula;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "sourceCredit")
public class SourceCredit {
	protected NoteType SourceCredit;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "statutoryNote")
public class StatutoryNote {
	protected NoteType StatutoryNote;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "editorialNote")
public class EditorialNote {
	protected NoteType EditorialNote;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "changeNote")
public class ChangeNote {
	protected NoteType ChangeNote;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "made")
public class Made {
	protected SignaturesType Made;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "approved")
public class Approved {
	protected SignaturesType Approved;
}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlElement(required = true, name = "schedule")
public class Schedule {
	protected AppendixType Schedule;
}
